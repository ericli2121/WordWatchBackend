const express = require('express');
const cors = require('cors');
const { getSubtitles, getVideoDetails } = require('youtube-caption-extractor');
const ytdl = require('@distube/ytdl-core');
const xml2js = require('xml2js');
const { Innertube } = require('youtubei.js');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());

// Rate limiting and retry logic
const userAgents = [
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Safari/605.1.15',
  'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
  'Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1'
];

function getRandomUserAgent() {
  return userAgents[Math.floor(Math.random() * userAgents.length)];
}

async function fetchWithRetry(url, options = {}, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      // Add random delay to avoid rate limiting
      if (attempt > 1) {
        const delay = Math.random() * 2000 + 1000; // 1-3 seconds
        console.log(`Attempt ${attempt}: Waiting ${delay.toFixed(0)}ms before retry...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
      
      // Rotate User-Agent for each attempt
      const headers = {
        ...options.headers,
        'User-Agent': getRandomUserAgent()
      };
      
      const response = await fetch(url, {
        ...options,
        headers
      });
      
      if (response.status === 429) {
        if (attempt === maxRetries) {
          throw new Error(`Rate limited after ${maxRetries} attempts. Please try again later.`);
        }
        console.log(`Rate limited (429) on attempt ${attempt}, retrying...`);
        continue;
      }
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return response;
    } catch (error) {
      if (attempt === maxRetries) {
        throw error;
      }
      console.log(`Attempt ${attempt} failed: ${error.message}, retrying...`);
    }
  }
}

// Helper function to extract subtitles using youtubei library
// test:    curl "http://localhost:3000/api/extract?videoID=dQw4w9WgXcQ&lang=ko"
async function extractSubtitlesWithYoutubei(videoID, lang = 'en') {
  try {
    // Initialize YouTube client
    const yt = await Innertube.create();
    
    // Get video info
    const info = await yt.getInfo(videoID);
    console.log('Captions:', info.captions);
    // Check if captions are available
    if (!info.captions) {
      throw new Error('No captions available for this video');
    }
    
    // Get caption tracks
    const captionTracks = info.captions.caption_tracks || [];
    const translationLanguages = info.captions.translation_languages || [];
/*     
    console.log('Caption Tracks:', captionTracks.map(track => ({
      language: track.language_code,
      name: track.name?.text || track.language_code,
      isAutoGenerated: track.kind === 'asr'
    })));
    
    console.log('Translation Languages:', translationLanguages.map(t => t.language_code)); */
    
    // Find the caption track matching the requested language
    let selectedTrack = captionTracks.find(track => track.language_code === lang);
    console.log('Selected Track:', selectedTrack);
/* 
    using youtubei   
    const video = await yt.getInfo(videoID);
    const transcriptInfo = await video.getTranscript();
    console.log('Transcript Info:', transcriptInfo);
    const transcript = await transcriptInfo.selectLanguage(lang);
    console.log('Transcript:', transcript); */
    
/*     const translatedTranscript =transcript.content.body.initial_segments.map(s => ({
      start: (s.start_ms / 1000).toFixed(1),
      dur: ((s.end_ms - s.start_ms) / 1000).toFixed(1),
      text: s.snippet.text
    }));
    console.log('Translated Transcript:', translatedTranscript); */

    // If specific language not found, try to auto-translate to the requested language
    if (!selectedTrack && captionTracks.length > 0 && translationLanguages.length > 0) {
      // Check if the requested language is available for auto-translation
      const translationLang = translationLanguages.find(t => t.language_code === lang);
      if (translationLang) {
        // Find the best base track for translation (prefer non-auto-generated)
        const baseTrack = captionTracks.find(track => track.kind !== 'asr') || captionTracks[0];
        console.log('Base Track:', baseTrack);
        if (baseTrack) {
          // Create auto-translated track URL by modifying the base URL
          // Keep the original language in lang parameter, add target language in tlang parameter
          let autoTranslatedUrl = baseTrack.base_url;
          
          // Handle different URL formats
         // if (autoTranslatedUrl.includes('&lang=')) {
         //   autoTranslatedUrl = autoTranslatedUrl.replace(
         //     /&lang=[^&]*/, 
         //     `&lang=${baseTrack.language_code}&tlang=${lang}&fmt=json3`
         //   );
         // } else {
         //   autoTranslatedUrl += `&lang=${baseTrack.language_code}&tlang=${lang}&fmt=json3`;
         // }
          
          selectedTrack = {
            ...baseTrack,
            language_code: lang,
            name: { text: `${translationLang.language_name} (Auto-translated)` },
            kind: 'asr_auto_translated',
            base_url: autoTranslatedUrl
          };
          console.log(`Language ${lang} not available, auto-translating from ${baseTrack.language_code}`);
          console.log('Auto-translated URL:', autoTranslatedUrl);
          
        }
      } else {
        console.log(`Language ${lang} not available for auto-translation`);
      }
    }
    
    // If still no track found, use the first available track
    if (!selectedTrack && captionTracks.length > 0) {
      selectedTrack = captionTracks[0];
      console.log(`Language ${lang} not available and no auto-translation, using ${selectedTrack.language_code}`);
    }
    
    if (!selectedTrack) {
      throw new Error(`No captions available in the requested language: ${lang}`);
    }
    
    // Get caption content
    let captionContent;
    if (selectedTrack.kind === 'asr_auto_translated') {
      // For auto-translated tracks, fetch from the modified URL with retry logic
      const headers = {
        'Accept': 'application/json, text/plain, */*',
        'Accept-Language': 'en-US,en;q=0.9',
        'Referer': 'https://www.youtube.com/',
        'Origin': 'https://www.youtube.com',
        'Cache-Control': 'no-cache',
        'Pragma': 'no-cache',
        'User-Agent': getRandomUserAgent()
      };
      
      // Print curl command for debugging
      const curlCommand = `curl -X GET "${selectedTrack.base_url}" \\
  -H "Accept: application/json, text/plain, */*" \\
  -H "Accept-Language: en-US,en;q=0.9" \\
  -H "Referer: https://www.youtube.com/" \\
  -H "Origin: https://www.youtube.com" \\
  -H "Cache-Control: no-cache" \\
  -H "Pragma: no-cache" \\
  -H "User-Agent: ${headers['User-Agent']}"`;
      /* 
      console.log('Curl command for auto-translated captions:');
      console.log(curlCommand);
      console.log(''); */
      
      const response = await fetch(selectedTrack.base_url, { headers });
      
      // Response is already checked in fetchWithRetry
      
      const captionText = await response.text();
      
      // Parse XML caption format
      const parser = new xml2js.Parser();
      const result = await parser.parseStringPromise(captionText);
      
      // Convert to youtubei.js format
      captionContent = {
        segments: result.transcript?.text?.map((element, index) => ({
          start_time: parseFloat(element.$.start || '0'),
          end_time: parseFloat(element.$.start || '0') + parseFloat(element.$.dur || '0'),
          snippet: {
            text: String(element._ || element || '').replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'")
          }
        })) || []
      };
    } else {
      // For regular tracks, use youtubei.js fetch method
      captionContent = await selectedTrack.fetch();
    }
    
    // Parse caption content
    const subtitles = [];
    if (captionContent && captionContent.segments) {
      captionContent.segments.forEach((segment) => {
        subtitles.push({
          start: segment.start_time.toFixed(1),
          dur: segment.end_time ? (segment.end_time - segment.start_time).toFixed(1) : '0.0',
          text: segment.snippet?.text || ''
        });
      });
    }
    /* 
    // Get all available languages including auto-translation options
    const availableLanguages = captionTracks.map(track => ({
      code: track.language_code,
      name: track.name?.text || track.language_code,
      isAutoGenerated: track.kind === 'asr',
      isAutoTranslated: false
    }));
    
    // Add auto-translation options if available
    translationLanguages.forEach(translationLang => {
      // Only add if not already in the list
      if (!availableLanguages.find(lang => lang.code === translationLang.language_code)) {
        availableLanguages.push({
          code: translationLang.language_code,
          name: `${translationLang.language_name} (Auto-translated)`,
          isAutoGenerated: false,
          isAutoTranslated: true
        });
      }
    }); */

    return {
      subtitles,
      language: selectedTrack.language_code,
      method: 'youtubei library',
      isAutoTranslated: selectedTrack.kind === 'asr_auto_translated',
     // availableLanguages
    };
  } catch (error) {
    throw new Error(`youtubei library extraction failed: ${error.message}`);
  }
}

// Helper function to extract subtitles using ytdl-core
async function extractSubtitlesWithYtdl(videoID, lang = 'en') {
  try {
    const videoUrl = `https://www.youtube.com/watch?v=${videoID}`;
    const info = await ytdl.getInfo(videoUrl);
    
    // Get available captions
    const captions = info.player_response.captions?.playerCaptionsTracklistRenderer?.captionTracks || [];
    
    // Find caption in requested language or fallback to available ones
    let selectedCaption = captions.find(caption => caption.languageCode === lang);
    if (!selectedCaption && captions.length > 0) {
      selectedCaption = captions[0]; // Use first available caption
    }
    
    if (!selectedCaption) {
      throw new Error('No captions available for this video');
    }
    
    // Fetch caption content
    const captionResponse = await fetch(selectedCaption.baseUrl);
    const captionText = await captionResponse.text();
    
    // Parse XML caption format
    const parser = new xml2js.Parser();
    const result = await parser.parseStringPromise(captionText);
    
    const subtitles = [];
    if (result.transcript && result.transcript.text) {
      result.transcript.text.forEach((element, index) => {
        const start = element.$.start || '0';
        const dur = element.$.dur || '0';
        const text = element._ || element || '';
        
        subtitles.push({
          start: parseFloat(start).toFixed(1),
          dur: parseFloat(dur).toFixed(1),
          text: String(text || '').replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'")
        });
      });
    }
    
    return {
      subtitles,
      language: selectedCaption.languageCode,
      availableLanguages: captions.map(c => ({ code: c.languageCode, name: c.name?.simpleText || c.languageCode }))
    };
  } catch (error) {
    throw new Error(`ytdl-core extraction failed: ${error.message}`);
  }
}

// API route for extracting subtitles and video details
app.get('/api/extract', async (req, res) => {
  const { videoID, lang, method } = req.query;

  // Validate required parameters
  if (!videoID) {
    return res.status(400).json({ 
      error: 'videoID parameter is required' 
    });
  }

  try {
    let result = {};
    
    // Try youtubei library first (unless specific method is requested)
    if (method === 'youtubei') {
      // Use youtubei library directly
      const youtubeiResult = await extractSubtitlesWithYoutubei(videoID, lang);
      result = {
        method: 'youtubei library',
        data: {
          subtitles: youtubeiResult.subtitles,
          language: youtubeiResult.language,
          isAutoTranslated: youtubeiResult.isAutoTranslated,
          availableLanguages: youtubeiResult.availableLanguages
        }
      };
    } else if (method === 'ytdl') {
      // Use ytdl-core directly
      const ytdlResult = await extractSubtitlesWithYtdl(videoID, lang);
      result = {
        method: 'ytdl-core',
        data: {
          subtitles: ytdlResult.subtitles,
          availableLanguages: ytdlResult.availableLanguages
        }
      };
    } else if (method === 'caption-extractor') {
      // Use youtube-caption-extractor directly
      const subtitles = await getSubtitles({ videoID, lang });
      const videoDetails = await getVideoDetails({ videoID, lang });
      
      result = {
        method: 'youtube-caption-extractor',
        data: {
          subtitles,
          videoDetails
        }
      };
    } else {
      // Default: Try youtubei library first, then fallback chain
      try {
        const youtubeiResult = await extractSubtitlesWithYoutubei(videoID, lang);
        
        result = {
          method: 'youtubei library',
          data: {
            subtitles: youtubeiResult.subtitles
          }
        };
      } catch (youtubeiError) {
        console.log('youtubei library failed, trying youtube-caption-extractor:', youtubeiError.message);
        
        try {
          const subtitles = await getSubtitles({ videoID, lang });
          // const videoDetails = await getVideoDetails({ videoID, lang });
          
          result = {
            method: 'youtube-caption-extractor (fallback)',
            data: {
              subtitles,
            }
          };
        } catch (extractorError) {
          console.log('youtube-caption-extractor failed, trying ytdl-core:', extractorError.message);
          
          // Final fallback to ytdl-core
          const ytdlResult = await extractSubtitlesWithYtdl(videoID, lang);
          result = {
            method: 'ytdl-core (fallback)',
            data: {
              subtitles: ytdlResult.subtitles,
            }
          };
        }
      }
    }
    
    res.status(200).json({ 
      success: true,
      ...result
    });
  } catch (error) {
    console.error('Error extracting data:', error);
    res.status(500).json({ 
      success: false,
      error: error.message,
      note: 'Both extraction methods failed. The video may not have subtitles available.'
    });
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'OK', 
    message: 'YouTube Extractor API is running' 
  });
});

// Root endpoint
app.get('/', (req, res) => {
  res.json({
    message: 'YouTube Extractor API',
    endpoints: {
      extract: '/api/extract?videoID=VIDEO_ID&lang=LANGUAGE_CODE&method=METHOD',
      health: '/health'
    },
    parameters: {
      videoID: 'YouTube video ID (required)',
      lang: 'Language code (optional, e.g., "en", "es", "fr")',
      method: 'Extraction method: "ytdl" for ytdl-core, "caption-extractor" for youtube-caption-extractor, or omit for auto-fallback'
    },
    examples: [
      '/api/extract?videoID=dQw4w9WgXcQ&lang=en',
      '/api/extract?videoID=dQw4w9WgXcQ&method=ytdl',
      '/api/extract?videoID=dQw4w9WgXcQ&method=caption-extractor',
      '/api/extract?videoID=dQw4w9WgXcQ&lang=es&method=ytdl'
    ],
    note: 'Now using YouTube InnerTube API v1 as primary method with automatic fallback chain: InnerTube API v1 â†’ caption-extractor â†’ ytdl-core'
  });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ 
    success: false,
    error: 'Something went wrong!' 
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ 
    success: false,
    error: 'Endpoint not found' 
  });
});

app.listen(PORT, () => {
  console.log(`ðŸš€ YouTube Extractor API server is running on port ${PORT}`);
  console.log(`ðŸ“¡ API endpoint: http://localhost:${PORT}/api/extract`);
  console.log(`ðŸ’š Health check: http://localhost:${PORT}/health`);
});
