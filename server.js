const express = require('express');
const cors = require('cors');
const { getSubtitles, getVideoDetails } = require('youtube-caption-extractor');
const ytdl = require('@distube/ytdl-core');
const xml2js = require('xml2js');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());

// Helper function to extract
//  subtitles using YouTube InnerTube API v1

const userAgents = [
  'Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0',
  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) Safari/605.1.15',
  'Mozilla/5.0 (X11; Linux x86_64) Firefox/121.0',
  'Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) Safari/604.1'
];

function getRandomUserAgent() {
  return userAgents[Math.floor(Math.random() * userAgents.length)];
}

async function extractSubtitlesWithInnerTube(videoID, lang = 'en') {
  try {
    // YouTube InnerTube API v1 endpoint
    const INNERTUBE_API_URL = 'https://www.youtube.com/youtubei/v1/player';
    

    // Required headers and context for InnerTube API
    const headers = {
      'Content-Type': 'application/json',
      'User-Agent': getRandomUserAgent(),
      'X-YouTube-Client-Name': '1',
      'X-YouTube-Client-Version': '2.20231219.01.00',
      'Origin': 'https://www.youtube.com',
      'Referer': 'https://www.youtube.com/'
    };
    
    // InnerTube API request payload - includes captions and auto-translated captions
    const payload = {
      context: {
        client: {
          clientName: 'WEB',
          clientVersion: '2.20231219.01.00',
          hl: 'en',
          gl: 'US'
        }
      },
      videoId: videoID
    };
    
    // Make request to InnerTube API
    const response = await fetch(INNERTUBE_API_URL, {
      method: 'POST',
      headers: headers,
      body: JSON.stringify(payload)
    });
    
      if (!response.ok) {
        console.log('InnerTube API URL:', INNERTUBE_API_URL);
        console.log('Request payload:', JSON.stringify(payload, null, 2));
        console.log('Response status:', response.status, response.statusText);
        const errorText = await response.text();
        console.log('Error response:', errorText);
        throw new Error(`InnerTube API request failed: ${response.status} ${response.statusText}`);
      }
    
    const data = await response.json();
    
    // Check if captions are available
    if (!data.captions || !data.captions.playerCaptionsTracklistRenderer) {
      throw new Error('No captions available for this video');
    }
    
    const captionRenderer = data.captions.playerCaptionsTracklistRenderer;
    const captionTracks = captionRenderer.captionTracks || [];
    const autoGeneratedTracks = captionRenderer.audioTracks || [];
    
    // Log only caption tracks and translation languages
    // console.log('Caption Tracks:', JSON.stringify(captionTracks, null, 2));
    // console.log('Translation Languages:', JSON.stringify(captionRenderer.translationLanguages, null, 2));
    
    // Combine regular captions and auto-generated captions
    const allTracks = [...captionTracks, ...autoGeneratedTracks];
    
    // Find the caption track matching the requested language
    let selectedTrack = allTracks.find(track => track.languageCode === lang);
    
    // If specific language not found, try to auto-translate to the requested language
    if (!selectedTrack && allTracks.length > 0 && captionRenderer.translationLanguages) {
      console.log('Available translation languages:', captionRenderer.translationLanguages.map(t => t.languageCode));
      
      // Check if the requested language is available for auto-translation
      const translationLang = captionRenderer.translationLanguages.find(t => t.languageCode === lang);
      if (translationLang) {
        // Find the best base track for translation (prefer non-auto-generated)
        const baseTrack = allTracks.find(track => track.kind !== 'asr') || allTracks[0];
        
        if (baseTrack) {
          // Create auto-translated track URL by modifying the base URL
          // Keep the original language in lang parameter, add target language in tlang parameter
          let autoTranslatedUrl = baseTrack.baseUrl;
          
          // Handle different URL formats
          if (autoTranslatedUrl.includes('&lang=')) {
            autoTranslatedUrl = autoTranslatedUrl.replace(
              /&lang=[^&]*/, 
              `&lang=${baseTrack.languageCode}&tlang=${lang}`
            );
          } else {
            autoTranslatedUrl += `&lang=${baseTrack.languageCode}&tlang=${lang}`;
          }
          
          selectedTrack = {
            ...baseTrack,
            languageCode: lang,
            baseUrl: autoTranslatedUrl,
            name: { simpleText: `${translationLang.languageName} (Auto-translated)` },
            kind: 'asr_auto_translated'
          };
          console.log(`Language ${lang} not available, auto-translating from ${baseTrack.languageCode}`);
        }
      } else {
        console.log(`Language ${lang} not available for auto-translation`);
      }
    }
    
    // If still no track found, use the first available track
    if (!selectedTrack && allTracks.length > 0) {
      selectedTrack = allTracks[0];
      console.log(`Language ${lang} not available and no auto-translation, using ${selectedTrack.languageCode}`);
    }
    
    if (!selectedTrack) {
      throw new Error(`No captions available in the requested language: ${lang}`);
    }
    
    // Fetch the caption content
    const captionResponse = await fetch(selectedTrack.baseUrl, {
      headers: {
        'User-Agent': getRandomUserAgent(),
        'Accept': 'application/json, text/plain, */*',
        'Accept-Language': 'en-US,en;q=0.9',
        'Referer': 'https://www.youtube.com/',
        'Origin': 'https://www.youtube.com'
      }
    });
    if (!captionResponse.ok) {
      console.log('Failed to fetch caption content:', selectedTrack.baseUrl);
      throw new Error(`Failed to fetch caption content: ${captionResponse.status}`);
    }
    
    const captionText = await captionResponse.text();
    
    // Parse XML caption format
    const parser = new xml2js.Parser();
    const result = await parser.parseStringPromise(captionText);
    
    const subtitles = [];
    if (result.transcript && result.transcript.text) {
      console.log("transcript result", result);
      result.transcript.text.forEach((element, index) => {
        const start = element.$.start || '0';
        const dur = element.$.dur || '0';
        const text = element._ || element || '';
        
        subtitles.push({
          start: parseFloat(start).toFixed(1),
          dur: parseFloat(dur).toFixed(1),
          text: String(text || '').replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'")
        });
      });
    }
    
    // Get all available languages including auto-translation options
    const availableLanguages = allTracks.map(track => ({
      code: track.languageCode,
      name: track.name?.simpleText || track.languageCode,
      isAutoGenerated: track.kind === 'asr' || track.kind === 'asr_auto',
      isAutoTranslated: false
    }));

    // Add auto-translation options if available
    if (captionRenderer.translationLanguages) {
      captionRenderer.translationLanguages.forEach(translationLang => {
        // Only add if not already in the list
        if (!availableLanguages.find(lang => lang.code === translationLang.languageCode)) {
          availableLanguages.push({
            code: translationLang.languageCode,
            name: `${translationLang.languageName} (Auto-translated)`,
            isAutoGenerated: false,
            isAutoTranslated: true
          });
        }
      });
    }

    return {
      subtitles,
      language: selectedTrack.languageCode,
      method: 'InnerTube API v1',
      isAutoTranslated: selectedTrack.kind === 'asr_auto_translated',
      availableLanguages
    };
  } catch (error) {
    throw new Error(`InnerTube API v1 extraction failed: ${error.message}`);
  }
}

// Helper function to extract subtitles using ytdl-core
async function extractSubtitlesWithYtdl(videoID, lang = 'en') {
  try {
    const videoUrl = `https://www.youtube.com/watch?v=${videoID}`;
    const info = await ytdl.getInfo(videoUrl);
    
    // Get available captions
    const captions = info.player_response.captions?.playerCaptionsTracklistRenderer?.captionTracks || [];
    
    // Find caption in requested language or fallback to available ones
    let selectedCaption = captions.find(caption => caption.languageCode === lang);
    if (!selectedCaption && captions.length > 0) {
      selectedCaption = captions[0]; // Use first available caption
    }
    
    if (!selectedCaption) {
      throw new Error('No captions available for this video');
    }
    
    // Fetch caption content
    const captionResponse = await fetch(selectedCaption.baseUrl);
    const captionText = await captionResponse.text();
    
    // Parse XML caption format
    const parser = new xml2js.Parser();
    const result = await parser.parseStringPromise(captionText);
    
    const subtitles = [];
    if (result.transcript && result.transcript.text) {
      result.transcript.text.forEach((element, index) => {
        const start = element.$.start || '0';
        const dur = element.$.dur || '0';
        const text = element._ || element || '';
        
        subtitles.push({
          start: parseFloat(start).toFixed(1),
          dur: parseFloat(dur).toFixed(1),
          text: String(text || '').replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '"').replace(/&#39;/g, "'")
        });
      });
    }
    
    return {
      subtitles,
      language: selectedCaption.languageCode,
      availableLanguages: captions.map(c => ({ code: c.languageCode, name: c.name?.simpleText || c.languageCode }))
    };
  } catch (error) {
    throw new Error(`ytdl-core extraction failed: ${error.message}`);
  }
}

// API route for extracting subtitles and video details
app.get('/api/extract', async (req, res) => {
  const { videoID, lang, method } = req.query;

  // Validate required parameters
  if (!videoID) {
    return res.status(400).json({ 
      error: 'videoID parameter is required' 
    });
  }

  try {
    let result = {};
    
    // Try InnerTube API v1 first (unless specific method is requested)
    if (method === 'ytdl') {
      // Use ytdl-core directly
      const ytdlResult = await extractSubtitlesWithYtdl(videoID, lang);
      result = {
        method: 'ytdl-core',
        data: {
          subtitles: ytdlResult.subtitles,
          availableLanguages: ytdlResult.availableLanguages
        }
      };
    } else if (method === 'caption-extractor') {
      // Use youtube-caption-extractor directly
      const subtitles = await getSubtitles({ videoID, lang });
      const videoDetails = await getVideoDetails({ videoID, lang });
      
      result = {
        method: 'youtube-caption-extractor',
        data: {
          subtitles,
          videoDetails
        }
      };
    } else {
      // Default: Try InnerTube API v1 first, then fallback chain
      try {
        const innerTubeResult = await extractSubtitlesWithInnerTube(videoID, lang);
        
        result = {
          method: 'InnerTube API v1',
          data: {
            subtitles: innerTubeResult.subtitles,
            language: innerTubeResult.language,
            isAutoTranslated: innerTubeResult.isAutoTranslated,
            availableLanguages: innerTubeResult.availableLanguages
          }
        };
      } catch (innerTubeError) {
        console.log('InnerTube API v1 failed, trying youtube-caption-extractor:', innerTubeError.message);
        
        try {
          const subtitles = await getSubtitles({ videoID, lang });
          const videoDetails = await getVideoDetails({ videoID, lang });
          
          result = {
            method: 'youtube-caption-extractor (fallback)',
            data: {
              subtitles,
              videoDetails,
              note: 'InnerTube API v1 failed, used youtube-caption-extractor as fallback'
            }
          };
        } catch (extractorError) {
          console.log('youtube-caption-extractor failed, trying ytdl-core:', extractorError.message);
          
          // Final fallback to ytdl-core
          const ytdlResult = await extractSubtitlesWithYtdl(videoID, lang);
          result = {
            method: 'ytdl-core (fallback)',
            data: {
              subtitles: ytdlResult.subtitles,
              availableLanguages: ytdlResult.availableLanguages,
              note: 'Both InnerTube API v1 and youtube-caption-extractor failed, used ytdl-core as final fallback'
            }
          };
        }
      }
    }
    
    res.status(200).json({ 
      success: true,
      ...result
    });
  } catch (error) {
    console.error('Error extracting data:', error);
    res.status(500).json({ 
      success: false,
      error: error.message,
      note: 'Both extraction methods failed. The video may not have subtitles available.'
    });
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ 
    status: 'OK', 
    message: 'YouTube Extractor API is running' 
  });
});

// Root endpoint
app.get('/', (req, res) => {
  res.json({
    message: 'YouTube Extractor API',
    endpoints: {
      extract: '/api/extract?videoID=VIDEO_ID&lang=LANGUAGE_CODE&method=METHOD',
      health: '/health'
    },
    parameters: {
      videoID: 'YouTube video ID (required)',
      lang: 'Language code (optional, e.g., "en", "es", "fr")',
      method: 'Extraction method: "ytdl" for ytdl-core, "caption-extractor" for youtube-caption-extractor, or omit for auto-fallback'
    },
    examples: [
      '/api/extract?videoID=dQw4w9WgXcQ&lang=en',
      '/api/extract?videoID=dQw4w9WgXcQ&method=ytdl',
      '/api/extract?videoID=dQw4w9WgXcQ&method=caption-extractor',
      '/api/extract?videoID=dQw4w9WgXcQ&lang=es&method=ytdl'
    ],
    note: 'Now using YouTube InnerTube API v1 as primary method with automatic fallback chain: InnerTube API v1 â†’ caption-extractor â†’ ytdl-core'
  });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ 
    success: false,
    error: 'Something went wrong!' 
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ 
    success: false,
    error: 'Endpoint not found' 
  });
});

app.listen(PORT, () => {
  console.log(`ðŸš€ YouTube Extractor API server is running on port ${PORT}`);
  console.log(`ðŸ“¡ API endpoint: http://localhost:${PORT}/api/extract`);
  console.log(`ðŸ’š Health check: http://localhost:${PORT}/health`);
});
